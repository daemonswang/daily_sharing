## 可重现
假设做一件事可以通过一个函数进行建模，事件的输入看做函数的自变量，事件的输出就是函数的结果。可重现行就是在函数和输入都已知的情况下，结果是固定的一致的（不会随着其他无关因素的变化而变化）。

可重现性意味着（在特定条件下）方法和参数选择是正确的。现在有个比较热门的名词“复盘”，当我们准备做一件事，从前到后谋划，计划，执行，结果，“复盘”是我们可以过一段时间得到一个结果后，反向倒推，找出问题，哪个环节不正确不恰当。

## 体现

### 代码的可重现
顾名思义，表现为函数和类的可重现，看似不难其实不简单，如何使得代码在各种工况下，相同的输入，得到相同的输出，这需要考虑极多的场景：
- 正常来说，以开车来说，走主路干路，很好走，但实际的情况是难免要窄路小路，断头路。。。
- 异常或者错误处理也就是走小路，断头路。。。通常程序中的错误和异常处理代码会占到代码总量约20%左右（视不同行业安全性，可靠性的要求不同），写代码过程中一定要做最坏的假设而不要抱有“这个是个极小概率”的想法，记住“小概率事件也必然会发生”。
- 异常或者错误可能来自代码本身，也有可能是系统引起的，比如内存耗尽，CPU耗尽，硬盘空间不足，写代码过程中都需要考虑到（可能需要系统层面的解决方案）

### 二进制安装包的可重现
随着项目的不断演进，版本的不断迭代，如何使得在不同时间把相同的代码编译出一个相同的安装包的能力变得越发重要！！！

这里需要考虑一下几方面的因素：
- 编译环境（编译器，标准库）
- 外部的依赖（第三方库）
- 代码本身（git的tag）
- 其他安装包制作过程可能涉及的一些服务（比如pki）

只有上述每一个因素都能保持稳定最终的结果才有可能达到可重现的效果，考虑到这些因素并不是全部，需要做些什么呢？
- 通过docker等虚拟化的技术实现编译环境的固化
- 通过建立本地的第三方库减少外部依赖
- 尽量稳定外部服务的接口，做好兼容性的预留

### 流程的可重现
一般来说不同的企业会有不同的开发流程，但至少都会遵从一致的流程，作为企业的知识积淀的一部分，流程给开发人员提供了一个框架，指导着开发者的行为。

大企业 vs 小企业？
对于流程，大企业和小企业有不同的看法和关注度，大企业更加关注流程，舍得投入，反观小企业关注和投入可能就没办法和大企业比。企业通过流程来约束或者指导员工的行为，从而实现可替代性，不管谁在这个位置，只要你遵从这个流程那产出也不会有太大的出入。小公司因缺少这个指导和约束，可以给人更多的个人发挥，往往会激发出更多的英雄式的员工，公司的成败会受到他们比较大的影响。

### 项目，产品的可重现
每个项目和产品都是由多个流程 + 源代码 + 环境，自底向上也会得到项目和产品的可重现。